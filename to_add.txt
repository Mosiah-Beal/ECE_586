1. Error Handling for Unrecognized Opcodes
Current:
instruction Instructions::getInstruction(int opcode) {
    if (instructionSet.count(opcode) > 0) {
        return instructionSet.at(opcode);
    } else {
        // Handle the case where the opcode does not exist in the map
        instruction defaultInst;
        defaultInst.type = -1;
        defaultInst.addressMode = -1;
        return defaultInst;
    }
}
Suggested:
logging an error or throwing an exception to handle this more explicitly:
#include <stdexcept> // Include at the top of your file

instruction Instructions::getInstruction(int opcode) {
    if (instructionSet.count(opcode) > 0) {
        return instructionSet.at(opcode);
    } else {
        throw std::runtime_error("Unrecognized opcode: " + std::to_string(opcode));
    }
}
This will halt execution with a clear error message if an invalid opcode is encountered, which is typically desirable during development to catch mistakes.
// CHECK where checks are happining in the program
//

/***********************************/

2. Stall and Flush Implementations
Current:
void Pipeline::stall(void) {
    numStalls++;
    // insert NOP(s) into stages
}

void Pipeline::flush(void) {
    // TODO: Implement
    std::cout << "Not implemented" << std::endl;
}

//might be like:  

Implementing stall and flush mechanisms:
void Pipeline::stall(void) {
    numStalls++;
    for (int i = 0; i < stages.size() - 1; i++) {
        stages[i] = NOPInstruction(); // Assuming NOPInstruction returns a default NOP instruction struct
    }
}

//Flush 
// Notes: We need to determine for which stage to flush bc we might have have valid instruction
	// 
void Pipeline::flush(void) {
    stages.clear(); // Clear all stages
    stages.resize(5); // Reset the pipeline stages
    std::cout << "Pipeline flushed." << std::endl;
}
Ensure you define NOPInstruction() or an equivalent method to create a no-operation instruction. Adjusting the stages array directly can help handle the pipeline dynamics during stalls and flushes.

/***********************************/

3. Correct Memory Address Calculation
Current:
case 12: // LDW
    status.registers[execInstr.rt] = status.memory[execInstr.imm];
    break;
case 13: // STW
    status.memory[execInstr.imm] = status.registers[execInstr.rt];
    break;
Suggested :
Adjusting for base register and offset in memory access:
case 12: // LDW
    status.registers[execInstr.rt] = status.memory[status.registers[execInstr.rs] + execInstr.imm];
    break;
case 13: // STW
    status.memory[status.registers[execInstr.rs] + execInstr.imm] = status.registers[execInstr.rt];
    break;
This change ensures that LDW and STW instructions calculate the effective address by adding the base register's value to the immediate offset, reflecting typical MIPS memory addressing.

/***********************************/
4. Branch Offset Calculation and Program Counter Update
Current:
case 14: // BZ
    if (status.registers[execInstr.rt] == 0) {
        status.PC += execInstr.imm * 4;
    }
    break;
case 15: // BEQ
    if (status.registers[execInstr.rt] == status.registers[execInstr.rs]) {
        status.PC += execInstr.imm * 4;
    }
    break;
Suggested:
Ensuring branch offsets are correctly calculated:
case 14: // BZ
    if (status.registers[execInstr.rt] == 0) {
        status.PC = status.PC + (execInstr.imm << 2);
    }
    break;
case 15: // BEQ
    if (status.registers[execInstr.rt] == status.registers[execInstr.rs]) {
        status.PC = status.PC + (execInstr.imm << 2);
    }
    break;